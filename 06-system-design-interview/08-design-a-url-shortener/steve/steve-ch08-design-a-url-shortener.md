# Chapter 8: Design A URL Shortener

## Step 1 - Understand the problem and establish design scope

### Basic use cases:
1. URL shortening: given a long URL => return a much shorter URL
2. URL redirecting: given a shorter URL => redirect to the original URL
3. High availability, scalability, and fault tolerance considerations


### Back of the envelope estimation
- Write operation: 100 million URLs are generated per day.
- Write operation per second: 100 million / 24 /3600 = 1160
- Read operation: Assuming ratio of read operation to write operation is 10:1, read
operation per second: 1160 * 10 = 11,600
- Assuming the URL shortener service will run for 10 years, this means we must support
100 million * 365 * 10 = 365 billion records.
- Assume average URL length is 100.
- Storage requirement over 10 years: 365 billion * 100 bytes * 10 years = 365 TB

## Step 2 - Propose high-level design and get buy-in

### API Endpoints

1. URL shortening. To create a new short URL, a client sends a POST request, which contains
one parameter: the original long URL. The API looks like this:
POST api/v1/data/shorten
- request parameter: {longUrl: longURLString}
- return shortURL
2. URL redirecting. To redirect a short URL to the corresponding long URL, a client sends a
GET request. The API looks like this:
GET api/v1/shortUrl
- Return longURL for HTTP redirection

### URL redirecting
1. 301 redirect
- A 301 redirect shows that the requested URL is “permanently” moved to the
long URL. Since it is permanently redirected, the browser caches the response, and
subsequent requests for the same URL will not be sent to the URL shortening service.
Instead, requests are redirected to the long URL server directly.
2. 302 redirect
- A 302 redirect means that the URL is “temporarily” moved to the long URL,
meaning that subsequent requests for the same URL will be sent to the URL shortening
service first. Then, they are redirected to the long URL server.

### URL shortening
The hash function must satisfy the following requirements:
- Each longURL must be hashed to one hashValue.
- Each hashValue can be mapped back to the longURL.

## Step 3 - Design deep dive
### Data model
In the high-level design, everything is stored in a hash table.

### Hash function
Hash function is used to hash a long URL to a short URL, also known as hashValue.
#### Hash value length
The hashValue consists of characters from [0-9, a-z, A-Z], containing 10 + 26 + 26 = 62
possible characters. To figure out the length of hashValue, find the smallest n such that 62^n
≥ 365 billion. The system must support up to 365 billion URLs based on the back of the
envelope estimation. Table 8-1 shows the length of hashValue and the corresponding
maximal number of URLs it can support.

#### Hash + collision resolution
To shorten a long URL, we should implement a hash function that hashes a long URL to a 7-
character string. A straightforward solution is to use well-known hash functions like CRC32,
MD5, or SHA-1. The following table compares the hash results after applying different hash
functions on this URL: https://en.wikipedia.org/wiki/Systems_design.

#### Base 62 conversion
Base conversion is another approach commonly used for URL shorteners. Base conversion
helps to convert the same number between its different number representation systems. Base
62 conversion is used as there are 62 possible characters for hashValue. Let us use an
example to explain how the conversion works: convert 1115710 to base 62 representation
(1115710 represents 11157 in a base 10 system).

### URL shortening deep dive
As one of the core pieces of the system, we want the URL shortening flow to be logically
simple and functional.

1. longURL is the input.
2. The system checks if the longURL is in the database.
3. If it is, it means the longURL was converted to shortURL before. In this case, fetch the
shortURL from the database and return it to the client.
4. If not, the longURL is new. A new unique ID (primary key) Is generated by the unique
ID generator.
5. Convert the ID to shortURL with base 62 conversion.
6. Create a new database row with the ID, shortURL, and longURL.

### URL redirecting deep dive
1. A user clicks a short URL link: https://tinyurl.com/zn9edcu
2. The load balancer forwards the request to web servers.
3. If a shortURL is already in the cache, return the longURL directly.
4. If a shortURL is not in the cache, fetch the longURL from the database. If it is not in the
database, it is likely a user entered an invalid shortURL.
5. The longURL is returned to the user.

## Step 4 - Wrap up

API design, data model, hash function, URL shortening, and URL redirecting.